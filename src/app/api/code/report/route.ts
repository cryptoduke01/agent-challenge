import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const { analysisData, reportType = 'summary', includeCharts = true } = await request.json();

    if (!analysisData) {
      return NextResponse.json(
        { error: 'Analysis data is required' },
        { status: 400 }
      );
    }

    // Generate comprehensive report
    const report = generateComprehensiveReport(analysisData, reportType, includeCharts);

    return NextResponse.json(report);

  } catch (error) {
    console.error('Report generation error:', error);
    return NextResponse.json(
      { error: 'Failed to generate report' },
      { status: 500 }
    );
  }
}

function generateComprehensiveReport(analysisData: any, reportType: string, includeCharts: boolean): any {
  const title = 'CodeGuardian AI Analysis Report';
  
  // Generate executive summary
  const executiveSummary = generateExecutiveSummary(analysisData);
  
  // Generate main summary
  const summary = generateMainSummary(analysisData);
  
  // Generate sections
  const sections = generateReportSections(analysisData, reportType);
  
  // Generate charts if requested
  const charts = includeCharts ? generateCharts(analysisData) : undefined;
  
  return {
    title,
    summary,
    executiveSummary,
    sections,
    charts,
  };
}

function generateExecutiveSummary(analysisData: any): string {
  const scores = [];
  
  if (analysisData.codeAnalysis?.qualityScore) {
    scores.push(`Code Quality: ${analysisData.codeAnalysis.qualityScore}/100`);
  }
  
  if (analysisData.securityScan?.securityScore) {
    scores.push(`Security Score: ${analysisData.securityScan.securityScore}/100`);
  }
  
  if (analysisData.performanceAnalysis?.performanceScore) {
    scores.push(`Performance Score: ${analysisData.performanceAnalysis.performanceScore}/100`);
  }
  
  const overallScore = scores.length > 0 
    ? Math.round(scores.reduce((sum, score) => sum + parseInt(score.split(': ')[1].split('/')[0]), 0) / scores.length)
    : 0;
  
  let summary = `**Executive Summary**\n\n`;
  summary += `Overall Code Health Score: **${overallScore}/100**\n\n`;
  
  if (overallScore >= 80) {
    summary += `✅ **Excellent**: Your codebase is in excellent condition with high quality, security, and performance standards.\n\n`;
  } else if (overallScore >= 60) {
    summary += `⚠️ **Good**: Your codebase is in good condition but has room for improvement in some areas.\n\n`;
  } else {
    summary += `🚨 **Needs Attention**: Your codebase requires immediate attention to address quality, security, or performance issues.\n\n`;
  }
  
  if (analysisData.codeAnalysis?.issues?.length > 0) {
    summary += `**Critical Issues Found**: ${analysisData.codeAnalysis.issues.filter((i: any) => i.severity === 'critical').length} critical issues require immediate attention.\n\n`;
  }
  
  if (analysisData.securityScan?.vulnerabilities?.length > 0) {
    summary += `**Security Vulnerabilities**: ${analysisData.securityScan.vulnerabilities.length} security issues detected.\n\n`;
  }
  
  summary += `**Recommendations**: Implement the suggested improvements to enhance code quality, security, and performance.\n\n`;
  
  return summary;
}

function generateMainSummary(analysisData: any): string {
  let summary = `# CodeGuardian AI Analysis Report\n\n`;
  summary += `This comprehensive analysis was generated by CodeGuardian's AI-powered code review system.\n\n`;
  
  // Code Quality Summary
  if (analysisData.codeAnalysis) {
    summary += `## 📊 Code Quality Analysis\n\n`;
    summary += `- **Quality Score**: ${analysisData.codeAnalysis.qualityScore || 'N/A'}/100\n`;
    summary += `- **Complexity**: Cyclomatic ${analysisData.codeAnalysis.complexity?.cyclomatic || 'N/A'}, Cognitive ${analysisData.codeAnalysis.complexity?.cognitive || 'N/A'}\n`;
    summary += `- **Issues Found**: ${analysisData.codeAnalysis.issues?.length || 0}\n`;
    summary += `- **Suggestions**: ${analysisData.codeAnalysis.suggestions?.length || 0} improvement suggestions\n\n`;
  }
  
  // Security Summary
  if (analysisData.securityScan) {
    summary += `## 🔒 Security Analysis\n\n`;
    summary += `- **Security Score**: ${analysisData.securityScan.securityScore || 'N/A'}/100\n`;
    summary += `- **Vulnerabilities**: ${analysisData.securityScan.vulnerabilities?.length || 0} found\n`;
    summary += `- **OWASP Compliance**: ${analysisData.securityScan.compliance?.owasp?.score || 'N/A'}/100\n`;
    summary += `- **CWE Compliance**: ${analysisData.securityScan.compliance?.cwe?.score || 'N/A'}/100\n\n`;
  }
  
  // Performance Summary
  if (analysisData.performanceAnalysis) {
    summary += `## ⚡ Performance Analysis\n\n`;
    summary += `- **Performance Score**: ${analysisData.performanceAnalysis.performanceScore || 'N/A'}/100\n`;
    summary += `- **Bottlenecks**: ${analysisData.performanceAnalysis.bottlenecks?.length || 0} identified\n`;
    summary += `- **Estimated Load Time**: ${analysisData.performanceAnalysis.metrics?.estimatedLoadTime || 'N/A'}\n`;
    summary += `- **Memory Usage**: ${analysisData.performanceAnalysis.metrics?.memoryUsage || 'N/A'}\n\n`;
  }
  
  return summary;
}

function generateReportSections(analysisData: any, reportType: string): Array<{
  title: string;
  content: string;
  metrics?: any;
  recommendations?: string[];
}> {
  const sections = [];
  
  // Code Quality Section
  if (analysisData.codeAnalysis) {
    sections.push({
      title: 'Code Quality Analysis',
      content: generateCodeQualityContent(analysisData.codeAnalysis),
      metrics: {
        qualityScore: analysisData.codeAnalysis.qualityScore,
        complexity: analysisData.codeAnalysis.complexity,
        issues: analysisData.codeAnalysis.issues?.length || 0,
      },
      recommendations: analysisData.codeAnalysis.suggestions || [],
    });
  }
  
  // Security Section
  if (analysisData.securityScan) {
    sections.push({
      title: 'Security Analysis',
      content: generateSecurityContent(analysisData.securityScan),
      metrics: {
        securityScore: analysisData.securityScan.securityScore,
        vulnerabilities: analysisData.securityScan.vulnerabilities?.length || 0,
        critical: analysisData.securityScan.vulnerabilities?.filter((v: any) => v.severity === 'critical').length || 0,
      },
      recommendations: analysisData.securityScan.recommendations || [],
    });
  }
  
  // Performance Section
  if (analysisData.performanceAnalysis) {
    sections.push({
      title: 'Performance Analysis',
      content: generatePerformanceContent(analysisData.performanceAnalysis),
      metrics: {
        performanceScore: analysisData.performanceAnalysis.performanceScore,
        bottlenecks: analysisData.performanceAnalysis.bottlenecks?.length || 0,
        loadTime: analysisData.performanceAnalysis.metrics?.estimatedLoadTime,
      },
      recommendations: analysisData.performanceAnalysis.recommendations || [],
    });
  }
  
  return sections;
}

function generateCodeQualityContent(analysis: any): string {
  let content = `**Quality Score**: ${analysis.qualityScore}/100\n\n`;
  
  if (analysis.complexity) {
    content += `**Complexity Metrics**:\n`;
    content += `- Cyclomatic Complexity: ${analysis.complexity.cyclomatic}\n`;
    content += `- Cognitive Complexity: ${analysis.complexity.cognitive}\n`;
    content += `- Maintainability Index: ${analysis.complexity.maintainability}\n\n`;
  }
  
  if (analysis.metrics) {
    content += `**Code Metrics**:\n`;
    content += `- Lines of Code: ${analysis.metrics.linesOfCode}\n`;
    content += `- Functions: ${analysis.metrics.functions}\n`;
    content += `- Classes: ${analysis.metrics.classes}\n`;
    content += `- Comments: ${analysis.metrics.comments}\n\n`;
  }
  
  if (analysis.issues?.length > 0) {
    content += `**Issues Found**:\n`;
    analysis.issues.slice(0, 5).forEach((issue: any) => {
      content += `- ${issue.severity.toUpperCase()}: ${issue.message}\n`;
    });
    if (analysis.issues.length > 5) {
      content += `- ... and ${analysis.issues.length - 5} more issues\n`;
    }
  }
  
  return content;
}

function generateSecurityContent(analysis: any): string {
  let content = `**Security Score**: ${analysis.securityScore}/100\n\n`;
  
  if (analysis.vulnerabilities?.length > 0) {
    content += `**Vulnerabilities Found**:\n`;
    analysis.vulnerabilities.slice(0, 5).forEach((vuln: any) => {
      content += `- ${vuln.severity.toUpperCase()}: ${vuln.title}\n`;
    });
    if (analysis.vulnerabilities.length > 5) {
      content += `- ... and ${analysis.vulnerabilities.length - 5} more vulnerabilities\n`;
    }
    content += `\n`;
  }
  
  if (analysis.compliance) {
    content += `**Compliance Scores**:\n`;
    content += `- OWASP: ${analysis.compliance.owasp?.score || 'N/A'}/100\n`;
    content += `- CWE: ${analysis.compliance.cwe?.score || 'N/A'}/100\n\n`;
  }
  
  return content;
}

function generatePerformanceContent(analysis: any): string {
  let content = `**Performance Score**: ${analysis.performanceScore}/100\n\n`;
  
  if (analysis.bottlenecks?.length > 0) {
    content += `**Performance Bottlenecks**:\n`;
    analysis.bottlenecks.slice(0, 5).forEach((bottleneck: any) => {
      content += `- ${bottleneck.severity.toUpperCase()}: ${bottleneck.description}\n`;
    });
    if (analysis.bottlenecks.length > 5) {
      content += `- ... and ${analysis.bottlenecks.length - 5} more bottlenecks\n`;
    }
    content += `\n`;
  }
  
  if (analysis.metrics) {
    content += `**Performance Metrics**:\n`;
    content += `- Estimated Load Time: ${analysis.metrics.estimatedLoadTime}\n`;
    content += `- Memory Usage: ${analysis.metrics.memoryUsage}\n`;
    content += `- CPU Intensity: ${analysis.metrics.cpuIntensity}\n\n`;
  }
  
  return content;
}

function generateCharts(analysisData: any): Array<{
  type: string;
  title: string;
  data: any;
}> {
  const charts = [];
  
  // Quality Score Chart
  if (analysisData.codeAnalysis?.qualityScore) {
    charts.push({
      type: 'gauge',
      title: 'Code Quality Score',
      data: {
        value: analysisData.codeAnalysis.qualityScore,
        max: 100,
        thresholds: [
          { value: 80, color: 'green' },
          { value: 60, color: 'yellow' },
          { value: 0, color: 'red' },
        ],
      },
    });
  }
  
  // Security Score Chart
  if (analysisData.securityScan?.securityScore) {
    charts.push({
      type: 'gauge',
      title: 'Security Score',
      data: {
        value: analysisData.securityScan.securityScore,
        max: 100,
        thresholds: [
          { value: 90, color: 'green' },
          { value: 70, color: 'yellow' },
          { value: 0, color: 'red' },
        ],
      },
    });
  }
  
  // Performance Score Chart
  if (analysisData.performanceAnalysis?.performanceScore) {
    charts.push({
      type: 'gauge',
      title: 'Performance Score',
      data: {
        value: analysisData.performanceAnalysis.performanceScore,
        max: 100,
        thresholds: [
          { value: 85, color: 'green' },
          { value: 65, color: 'yellow' },
          { value: 0, color: 'red' },
        ],
      },
    });
  }
  
  return charts;
}
